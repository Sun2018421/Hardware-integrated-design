C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Final) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "lcd.h"
   2          #include "reg52.h"
   3          
   4          
   5          typedef unsigned int u16;   //对数据类型进行声明定义
   6          typedef unsigned char u8;
   7          
   8          
   9          char Outputchar[18]={48,49,50,51,52,53,54,55,56,57,43,45,42,47,40,41,46,61};
  10          #define MAXLEN 15
  11          char Opcodepoint = -1;  // +1 push 指向当前位置
  12          char Operandpoint = -1 ;
  13          char Statepoint = -1;
  14          float Operand[MAXLEN];  //Operadn[MAXLEN-1]为整数部分临时保存位置
  15          float a , b , c;
  16          #define temp Operand[MAXLEN-1]
  17          u8 Opcode[MAXLEN];
  18          u8 StateStack[MAXLEN];
  19          u8 times = 1;  //转换成float的长度标记
  20          u8 Decimalpoint = 0 ;//有无小数点
  21          u8 State = 0; //最开始在初始状态
  22          void changeState(){
  23   1      }
  24          void InitOpcodeStack(){
  25   1        Opcodepoint = -1;
  26   1      }
  27          void InitOperandStack(){
  28   1        Operandpoint = -1;
  29   1      }
  30          void InitStateStack(){
  31   1        Statepoint = -1;
  32   1      }
  33          /*
  34            优先级表
  35            -1 = < , 0 = = ,1 = >,2 = error
  36            + 0,- 1* 2,/ 3,( 4,) 5,# 6
  37            = -> #
  38            */
  39          char OpPri[7][7]={  
  40            {1,1,-1,-1,-1,1,1},
  41            {1,1,-1,-1,-1,1,1},
  42            {1,1,1,1,-1,1,1},
  43            {1,1,1,1,-1,1,1},
  44            {-1,-1,-1,-1,-1,0,2},
  45            {1,1,1,1,2,1,1},
  46            {-1,-1,-1,-1,-1,2,0}
  47          };
  48          
  49          void delay(u16 i){  
  50   1        while(i--);
  51   1      }
  52          /*
  53            P17->H1
  54            P16->H2
C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 2   

  55            P15->H3
  56            P14->H4
  57          
  58            P13->L1
  59            P12->L2
  60            P11->L3
  61            P10->L4
  62          */
  63          #define GPIO_KEY P1 //  0000 0000
  64          #define GPIO_BUTTON P3 //独立按键使用P3
  65          sbit K1 = P3^0; sbit K2 = P3^1;
  66          sbit K3 = P3^2; sbit K4 = P3^3;
  67          sbit K5 = P3^4; sbit K6 = P3^5;
  68          sbit K7 = P3^6; sbit K8 = P3^7;
  69          u8 isNum(u8 num){
  70   1        if((num>=0)&&(num<=9))
  71   1          return 1;
  72   1        return 0;
  73   1      }
  74          
  75          u8 KeyDown(void)
  76          {
  77   1        u8 KeyValue= 127;
  78   1        char a=0;
  79   1        GPIO_KEY=0x0f;
  80   1        if(GPIO_KEY!=0x0f)//读取按键是否按下
  81   1        {
  82   2          delay(1000);//延时10ms进行消抖
  83   2          if(GPIO_KEY!=0x0f)//再次检测键盘是否按下
  84   2          { 
  85   3            //测试列
  86   3            GPIO_KEY=0X0F;
  87   3            switch(GPIO_KEY)
  88   3            {
  89   4              case(0X07): KeyValue=0;break;
  90   4              case(0X0b): KeyValue=1;break;
  91   4              case(0X0d): KeyValue=2;break;
  92   4              case(0X0e): KeyValue=3;break;
  93   4            }
  94   3            //测试行
  95   3            GPIO_KEY=0XF0;
  96   3            switch(GPIO_KEY)
  97   3            {
  98   4              case(0X70): KeyValue=KeyValue;break;
  99   4              case(0Xb0): KeyValue=KeyValue+4;break;
 100   4              case(0Xd0): KeyValue=KeyValue+8;break;
 101   4              case(0Xe0): KeyValue=KeyValue+12;break;
 102   4            }
 103   3            
 104   3          }
 105   2        }
 106   1        //delay(1000);
 107   1        while((a<50)&&(GPIO_KEY!=0xf0))  //检测按键松手检测
 108   1        {
 109   2          delay(140);
 110   2          a++;
 111   2        }
 112   1        return KeyValue;
 113   1      }
 114          
 115          
 116          void Error(){
C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 3   

 117   1        
 118   1      }
 119          void handleNum(u8 num){
 120   1        u8 i ;
 121   1        float afterpoint = 0;
 122   1        afterpoint += num;
 123   1        if(Decimalpoint!=1){    //没有小数点
 124   2            temp = temp *10 + num;
 125   2        }
 126   1        else{
 127   2            for(i=0;i<times;i++){
 128   3                afterpoint = afterpoint*0.1;
 129   3            }
 130   2            temp = temp+afterpoint;
 131   2        }
 132   1      }
 133          char Precede(u8 op1,u8 op2){
 134   1        if(OpPri[op1][op2]==-1){
 135   2          return '<';
 136   2        }
 137   1        else if(OpPri[op1][op2]==0){
 138   2          return '=';
 139   2        }
 140   1        else if(OpPri[op1][op2]==1){
 141   2          return '>';
 142   2        }
 143   1        else {
 144   2          return '?';
 145   2        }
 146   1      }
 147          
 148          void PushOP(u8 op){
 149   1        Opcodepoint++;
 150   1        Opcode[Opcodepoint] = op;
 151   1      }
 152          
 153          u8 PopOP(){
 154   1        u8 op = Opcode[Opcodepoint];
 155   1        Opcodepoint--;
 156   1        return op;
 157   1      }
 158          void PushNum(){
 159   1        Operandpoint++;
 160   1        Operand[Operandpoint] = temp;
 161   1        //重置数字计数
 162   1        temp = 0;
 163   1        Decimalpoint= 0;   //重新开始小数
 164   1      }
 165          
 166          void Pushans(float ans){
 167   1        Operandpoint++;
 168   1        Operand[Operandpoint] = ans;
 169   1      }
 170          float PopNum(){
 171   1        float num = Operand[Operandpoint];
 172   1        Operandpoint--;
 173   1        return num;
 174   1      }
 175          float operate(float a, float b,u8 theta){
 176   1        if(theta==0){
 177   2          return a+b;
 178   2        }
C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 4   

 179   1        else if(theta ==1){
 180   2          return a-b;
 181   2        }
 182   1        else if(theta ==2){
 183   2          return a*b;
 184   2        }
 185   1        else 
 186   1          return a/b;
 187   1        
 188   1      }
 189          void handleOp(u8 op){
 190   1        char P = Precede(Opcode[Opcodepoint],op);
 191   1        u8 theta;
 192   1        float a, b;
 193   1        PushNum();          //todo: 如果最开始是符号有问题
 194   1        switch(P){
 195   2          case '<':
 196   2            PushOP(op);
 197   2            break;
 198   2          case '=':
 199   2            PopOP();
 200   2            break;
 201   2          case '>':
 202   2            theta = PopOP();
 203   2            b = PopNum();
 204   2            a = PopNum();
 205   2            Pushans(operate(a,b,theta));
 206   2            break;
 207   2          case '?':
 208   2            break;
 209   2        }
 210   1      }
 211          /*
 212          从独立按键输入字符
 213          */
 214          u8 keypros(){
 215   1        
 216   1        
 217   1        GPIO_BUTTON = 0xff;
 218   1        delay(1000);
 219   1        if(K1 == 0){
 220   2          while(!K1);
 221   2          return 10;  //'+'
 222   2        }
 223   1        if(K2 == 0){
 224   2          while(!K2);
 225   2          return 11; 
 226   2        }
 227   1        if(K3 == 0){
 228   2          while(!K3);
 229   2          return 12; 
 230   2        }
 231   1        if(K4 == 0){
 232   2          while(!K4);
 233   2          return 13; 
 234   2        }
 235   1        if(K5 == 0){
 236   2          while(!K5);
 237   2          return 14; 
 238   2        }
 239   1        if(K6 == 0){
 240   2          while(!K6);
C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 5   

 241   2          return 15; 
 242   2        }
 243   1        if(K7 == 0){
 244   2          while(!K7);
 245   2          return 16; 
 246   2        }
 247   1        if(K8 == 0){
 248   2          while(!K8);
 249   2          return 17; 
 250   2        }
 251   1        return 127;
 252   1      }
 253          
 254          u8 Getch(){
 255   1        u8 op = 127;
 256   1        while(op==127){
 257   2          op = keypros();
 258   2          if(op!=127)
 259   2            return op ;
 260   2          op = KeyDown();
 261   2            if(op!=127){
 262   3          return op;
 263   3          }
 264   2        }
 265   1      }
 266          
 267          void function_S0(){
 268   1          u8 num = Getch();
 269   1          LcdWriteData(Outputchar[num]);
 270   1      }
 271          
 272          void function_S1(){
 273   1      }
 274          
 275          void function_S2(){
 276   1      }
 277          
 278          void function_S3(){
 279   1      }
 280          
 281          void function_S4(){
 282   1      }
 283          
 284          void function_S5(){
 285   1      }
 286          
 287          void function_S6(){
 288   1      }
 289          void main(){
 290   1        LcdInit();
 291   1        InitOpcodeStack();
 292   1        InitOperandStack();
 293   1        while(1){
 294   2          switch(State){
 295   3            case 0:
 296   3              function_S0();
 297   3              break;
 298   3            case 1:
 299   3              function_S1();
 300   3              break;
 301   3            case 2:
 302   3              function_S2();
C51 COMPILER V9.60.0.0   MAIN                                                              01/03/2021 11:08:57 PAGE 6   

 303   3              break;
 304   3            case 3:
 305   3              function_S3();
 306   3              break;
 307   3            case 4:
 308   3              function_S4();
 309   3              break;
 310   3            case 5:
 311   3              function_S5();
 312   3              break;
 313   3            case 6:
 314   3              function_S6();
 315   3              break;
 316   3          }
 317   2        }
 318   1        
 319   1      }
*** WARNING C291 IN LINE 265 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1239    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    175      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
